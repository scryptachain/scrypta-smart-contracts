/**
 * NAME: ERC20
 * DESCRIPTION: ERC-20 implementation
 * AUTHOR: turinglabs
 * VERSION: 1.0.0
 * IMMUTABLE: false
 */

// DEFINING COMPILER VERSION
/* Scrypta v0.0.2 */

// ADDING EXTERNAL DEPENDENCIES
const { sum, round, subtract } = require('mathjs')

async function constructor() {}


function private: processdata(data){
    return new Promise(async response => {
        if(Object.keys(data).length > 0){
            let keys = Object.keys(data)
            for(let k in Object.keys(data)){

                console.log('ANALYZING DATA FOR ' + keys[k])
                let address = keys[k]

                for(let j in data[keys[k]]){
                    let written = data[keys[k]][j]
                    if(written.protocol === 'src20://'){
                        let data = written.data.split(':')
                        let action = data[0]
                        if(action === 'transfer'){
                            await transfer(data, address)
                        }else if(action === 'mint'){
                            await mint(data, address)
                        }else if(action === 'burn'){
                            await burn(data, address)
                        }
                    }
                }
            }
            response(true)
        }else{
            response(false)
        }
    })
}

async function public: eachBlock(block){
    if(block['data_written'] !== undefined){
        return await processdata(block['data_written'])
    }else{
        return false
    }
}

async function public: ifMempool(mempool){
    if(mempool['data_written'] !== undefined){
        return await processdata(mempool['data_written'])
    }else{
        return false
    }
}

function public: consensus(){
    // THIS FUNCTION WILL BE CALLED TO CHECK THE CONSENSUS BETWEEN NODES
    return new Promise(async response => {
        let state = await db.read()
        let hash = await scrypta.hash(state)
        response({
            state: state,
            hash: hash
        })
    })
}

function public: name(){
    return "MyToken"
}

function public: symbol(){
    return "MTT"
}

function public: owner(){
    return "LSJq6a6AMigCiRHGrby4TuHeGirJw2PL5c"
}

function public: decimals(){
    return 10
}

function public: totalSupply(){
    return 100000000
}

function public: balanceOf(){
    return new Promise(async response => {
        if(request.address !== undefined || (request.message.params !== undefined && request.message.params.address !== undefined)){
            if(request.message.params.address !== undefined){
                let address = request.message.params.address
                let balance = await db.read({"address": address})
                if(balance.length > 0){
                    response(balance.balance)
                }else{
                    response(0)
                }
            }else{
                let balance = await db.read({"address": request.address})
                if(balance.length > 0){
                    response(balance.balance)
                }else{
                    response(0)
                }
            }
        }else{
            response(false)
        }
    })
}

function private: transfer(data, address){
    return new Promise(async response => {
        
        /*
        * EXPECTED TRANSFER TRANSACTION IS:
        * src20://transfer:Li9BgCWhQrv8LhKD3U5HS47oencDrTDAZb:10000
        */
        
        let balance = await balanceOf()
        let to = data[1]
        let amount = data[2]

        if(to !== undefined && amount !== undefined && parseFloat(amount) > 0){
            let fromUser = await db.read({ "address": address })
            if(fromUser.length > 0){
                let fromUpdatedBalance = subtract(balance, amount)
                if(balance >= amount){
                    let toUser = await db.read({ "address": to })
                    if(toUser.length === 0){
                        await db.insert({
                            "address": to,
                            "balance": amount,
                            "last_update": block.height
                        })
                    }else{
                        let toUpdatedBalance = sum(toUser.balance, amount)
                        await db.update({ "address": to },
                            { $set: {
                                "balance": toUpdatedBalance,
                                "last_update": block.height
                            } 
                        })
                    }
                    await db.update({ "address": address },
                        { $set: {
                            "balance": fromUpdatedBalance,
                            "last_update": block.height
                        } 
                    })
                    response(true)
                } else {
                    console.log('NOT ENOUGH BALANCE')
                    response(false)
                }
            }else{
                console.log('USER NOT FOUND')
                response(false)
            }
        } else {
            console.log('MALFORMED REQUEST')
            response(false)
        }
    })
}

function private: mint(data, address){
    return new Promise(async response => {

        /*
        * EXPECTED MINT TRANSACTION IS:
        * src20://mint:10000
        */

        let amount = data[1]
        let owner = owner()

        if(amount !== undefined && address === owner && parseFloat(amount) > 0){
            let max = totalSupply()
            let ownerUser = await db.read({ "address": owner })
            if(ownerUser.length === 0){
                let validated = true

                /*
                * Check if amount is less than the max or is -1 which means it's unlimited
                */
                if(max !== -1 && amount > max){
                    validated = false
                }

                if(validated){
                    await db.insert({
                        "address": owner,
                        "balance": amount,
                        "last_update": block.height
                    })
                    response(true)
                }else{
                    console.log("CAN'T MINT MORE THAN MAX SUPPLY")
                    response(false)
                }
            }else{
                let validated = true

                // CHECK IF SUPPLY IS OPEN OR CLOSED
                if(max !== -1){

                    // IF SUPPLY IS CLOSED CHECK IF TOTAL SUPPLY IS REACHED OR NOT
                    let shares = await db.read()
                    let totalBalances = 0
                    for(let k in shares){
                        totalBalances = sum(totalBalances, shares[k].balance)
                    }

                    let expected = sum(totalBalances, amount)
                    if(expected > max){
                        validated = false
                    }else{
                        console.log("CAN'T MINT MORE THAN MAX SUPPLY")
                    }
                }

                // IF VALIDATED UPDATE OWNER BALANCE
                if(validated){
                    let updated = sum(ownerUser.balance, amount)
                    await db.update({ "address": owner },
                        { $set: {
                            "balance": updated,
                            "last_update": block.height
                        } 
                    })
                    response(true)
                }else{
                    response(false)
                }
            }
        }else{
            console.log('MALFORMED REQUEST')
            response(false)
        }
    })
}

function private: burn(data, address){
    return new Promise(async response => {
        /*
        * EXPECTED BURN TRANSACTION IS:
        * src20://burn:10000
        */
        
        let amount = data[1]

        if(amount !== undefined && parseFloat(amount) > 0){
            let fromUser = await db.read({ "address": address })
            if(fromUser.length > 0){
                let balance = await balanceOf()
                if(balance >= amount){
                    let updated = subtract(fromUser.balance, amount)
                    await db.update({ "address": to },
                        { $set: {
                            "balance": updated,
                            "last_update": block.height
                        } 
                    })
                    response(true)
                } else {
                    console.log('NOT ENOUGH BALANCE')
                    response(false)
                }
            }else{
                console.log('USER NOT FOUND')
                response(false)
            }
        }else{
            console.log('MALFORMED REQUEST')
            response(false)
        }
    })
}